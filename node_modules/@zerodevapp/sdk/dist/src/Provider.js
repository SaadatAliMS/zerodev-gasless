"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapV2Provider = exports.wrapProvider = void 0;
const contracts_new_1 = require("@zerodevapp/contracts-new");
const ZeroDevProvider_1 = require("./ZeroDevProvider");
const HttpRpcClient_1 = require("./HttpRpcClient");
const debug_1 = __importDefault(require("debug"));
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const KernelAccountV2API_1 = require("./KernelAccountV2API");
const debug = (0, debug_1.default)('aa.wrapProvider');
/**
 * wrap an existing provider to tunnel requests through Account Abstraction.
 * @param originalProvider the normal provider
 * @param config see ClientConfig for more info
 * @param originalSigner use this signer as the owner. of this wallet. By default, use the provider's signer
 */
async function wrapProvider(originalProvider, config, originalSigner, options = { bundlerGasCalculation: true }) {
    const entryPoint = contracts_new_1.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);
    const chainId = await originalProvider.getNetwork().then(net => net.chainId);
    const httpRpcClient = new HttpRpcClient_1.HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.projectId, options.skipFetchSetup, options.bundlerProvider);
    const accountAPI = BaseAccountAPI_1.BaseAccountAPI.create(config.implementation.accountAPIClass, {
        // Use our own provider because some providers like Magic doesn't support custom errors, which
        // we rely on for getting counterfactual address
        // Unless it's hardhat.
        provider: originalProvider,
        entryPointAddress: entryPoint.address,
        owner: originalSigner,
        index: config.index,
        factoryAddress: config.implementation.factoryAddress,
        paymasterAPI: config.paymasterAPI,
        accountAddress: config.walletAddress,
        httpRpcClient: (options === null || options === void 0 ? void 0 : options.bundlerGasCalculation) === true ? httpRpcClient : undefined,
        chainId,
        onlySendSponsoredTransaction: options.onlySendSponsoredTransaction
    });
    debug('config=', config);
    return await new ZeroDevProvider_1.ZeroDevProvider(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, accountAPI, options.transactionTimeout).init();
}
exports.wrapProvider = wrapProvider;
/**
 * wrap an existing provider to tunnel requests through Account Abstraction.
 * @param originalProvider the normal provider
 * @param config see ClientConfig for more info
 * @param originalSigner use this signer as the owner. of this wallet. By default, use the provider's signer
 */
async function wrapV2Provider(originalProvider, config, originalSigner, defaultValidator, validator, options = { bundlerGasCalculation: true }) {
    const entryPoint = contracts_new_1.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);
    const chainId = await originalProvider.getNetwork().then(net => net.chainId);
    const httpRpcClient = new HttpRpcClient_1.HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.projectId, options === null || options === void 0 ? void 0 : options.skipFetchSetup);
    //  const validator = new ECDSAValidator({
    //    entrypoint: entryPoint,
    //    mode: mode,
    //    kernelValidator: config.validatorAddress!,
    //    owner : originalSigner
    //  })
    const accountAPI = new KernelAccountV2API_1.KernelAccountV2API({
        // Use our own provider because some providers like Magic doesn't support custom errors, which
        // we rely on for getting counterfactual address
        // Unless it's hardhat.
        provider: originalProvider,
        entryPointAddress: entryPoint.address,
        owner: originalSigner,
        index: config.index,
        factoryAddress: config.implementation.factoryAddress,
        paymasterAPI: config.paymasterAPI,
        accountAddress: config.walletAddress,
        httpRpcClient: (options === null || options === void 0 ? void 0 : options.bundlerGasCalculation) === true ? httpRpcClient : undefined,
        validator,
        defaultValidator,
        chainId
    });
    debug('config=', config);
    return await new ZeroDevProvider_1.ZeroDevProvider(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, accountAPI, options.transactionTimeout).init();
}
exports.wrapV2Provider = wrapV2Provider;
//# sourceMappingURL=Provider.js.map