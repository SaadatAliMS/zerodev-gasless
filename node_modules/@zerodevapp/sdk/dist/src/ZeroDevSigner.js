"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeroDevSigner = exports.AssetType = void 0;
const properties_1 = require("@ethersproject/properties");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const ethers_1 = require("ethers");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("./utils");
const MoralisApiService_1 = __importDefault(require("./services/MoralisApiService"));
const multisend_1 = require("./multisend");
const constants = __importStar(require("./constants"));
var AssetType;
(function (AssetType) {
    AssetType[AssetType["ETH"] = 1] = "ETH";
    AssetType[AssetType["ERC20"] = 2] = "ERC20";
    AssetType[AssetType["ERC721"] = 3] = "ERC721";
    AssetType[AssetType["ERC1155"] = 4] = "ERC1155";
})(AssetType = exports.AssetType || (exports.AssetType = {}));
class ZeroDevSigner extends abstract_signer_1.Signer {
    // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference
    constructor(config, originalSigner, zdProvider, httpRpcClient, smartAccountAPI) {
        super();
        this.config = config;
        this.originalSigner = originalSigner;
        this.zdProvider = zdProvider;
        this.httpRpcClient = httpRpcClient;
        this.smartAccountAPI = smartAccountAPI;
        (0, properties_1.defineReadOnly)(this, 'provider', zdProvider);
    }
    // This one is called by Contract. It signs the request and passes in to Provider to be sent.
    async sendTransaction(transaction, executeBatchType = BaseAccountAPI_1.ExecuteType.EXECUTE, retryCount = 0) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const gasLimit = await transaction.gasLimit;
        const target = (_a = transaction.to) !== null && _a !== void 0 ? _a : '';
        const data = (_c = (_b = transaction.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '0x';
        const value = transaction.value;
        const maxFeePerGas = transaction.maxFeePerGas;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas;
        let userOperation;
        userOperation = await this.smartAccountAPI.createSignedUserOp({
            target,
            data,
            value,
            gasLimit,
            maxFeePerGas,
            maxPriorityFeePerGas
        }, executeBatchType);
        if (((_d = this.config.hooks) === null || _d === void 0 ? void 0 : _d.userOperationStarted) != null) {
            const proceed = await ((_e = this.config.hooks) === null || _e === void 0 ? void 0 : _e.userOperationStarted(await (0, properties_1.resolveProperties)(userOperation)));
            if (!proceed) {
                throw new Error('user operation rejected by user');
            }
        }
        try {
            await this.httpRpcClient.sendUserOpToBundler(userOperation);
        }
        catch (error) {
            console.error('sendUserOpToBundler failed', error);
            if (this.isReplacementOpError(error)) {
                console.error('Resending tx with Increased Gas fees');
                if (retryCount >= ((_f = this.config.maxTxRetries) !== null && _f !== void 0 ? _f : constants.DEFAULT_MAX_TX_RETRIES)) {
                    throw new Error('Maximum retry attempts exceeded');
                }
                return await this.resendTransactionWithIncreasedGasFees(transaction, userOperation, executeBatchType, retryCount);
            }
            throw this.unwrapError(error);
        }
        const transactionResponse = await this.zdProvider.constructUserOpTransactionResponse(userOperation);
        // Invoke the transaction hook
        const from = transaction.from;
        const to = transaction.to;
        (_h = (_g = this.config.hooks) === null || _g === void 0 ? void 0 : _g.transactionStarted) === null || _h === void 0 ? void 0 : _h.call(_g, {
            hash: transactionResponse.hash,
            from,
            to,
            value: value !== null && value !== void 0 ? value : 0,
            sponsored: userOperation.paymasterAndData !== '0x'
        });
        // TODO: handle errors - transaction that is "rejected" by bundler is _not likely_ to ever resolve its "wait()"
        return transactionResponse;
    }
    isReplacementOpError(errorIn) {
        var _a, _b;
        if (errorIn.body != null) {
            const errorBody = JSON.parse(errorIn.body);
            const failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
            return (_b = failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('replacement op must increase maxFeePerGas and MaxPriorityFeePerGas')) !== null && _b !== void 0 ? _b : false;
        }
        return false;
    }
    async resendTransactionWithIncreasedGasFees(transaction, userOperation, executeBatchType, retryCount) {
        retryCount++;
        const maxFeePerGas = ethers_1.BigNumber.from(userOperation.maxFeePerGas).mul(113).div(100);
        const maxPriorityFeePerGas = ethers_1.BigNumber.from(userOperation.maxPriorityFeePerGas).mul(113).div(100);
        return await (this === null || this === void 0 ? void 0 : this.sendTransaction(Object.assign(Object.assign({}, transaction), { maxFeePerGas, maxPriorityFeePerGas }), executeBatchType, retryCount));
    }
    unwrapError(errorIn) {
        var _a;
        if (errorIn.body != null) {
            const errorBody = JSON.parse(errorIn.body);
            let paymasterInfo = '';
            let failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
            if ((failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('FailedOp')) === true) {
                // TODO: better error extraction methods will be needed
                const matched = failedOpMessage.match(/FailedOp\((.*)\)/);
                if (matched != null) {
                    const split = matched[1].split(',');
                    paymasterInfo = `(paymaster address: ${split[1]})`;
                    failedOpMessage = split[2];
                }
            }
            const error = new Error(`The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo})`);
            error.stack = errorIn.stack;
            return error;
        }
        return errorIn;
    }
    async estimateGas(transaction, executeBatchType = BaseAccountAPI_1.ExecuteType.EXECUTE) {
        var _a, _b, _c;
        const tx = await (0, properties_1.resolveProperties)(this.checkTransaction(transaction));
        const userOperation = await this.smartAccountAPI.createUnsignedUserOp({
            target: (_a = tx.to) !== null && _a !== void 0 ? _a : '',
            data: (_c = (_b = tx.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '0x',
            value: tx.value,
            maxFeePerGas: tx.maxFeePerGas,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas
        }, executeBatchType);
        return ethers_1.BigNumber.from(await userOperation.preVerificationGas).add(ethers_1.BigNumber.from(await userOperation.verificationGasLimit)).add(ethers_1.BigNumber.from(await userOperation.callGasLimit));
    }
    async getUserOperationReceipt(hash) {
        return await this.httpRpcClient.getUserOperationReceipt(hash);
    }
    async verifyAllNecessaryFields(transactionRequest) {
        if (transactionRequest.to == null) {
            throw new Error('Missing call target');
        }
        if (transactionRequest.data == null && transactionRequest.value == null) {
            // TBD: banning no-op UserOps seems to make sense on provider level
            throw new Error('Missing call data or value');
        }
    }
    connect(provider) {
        throw new Error('changing providers is not supported');
    }
    async getAddress() {
        if (this.address == null) {
            this.address = await this.zdProvider.getSenderAccountAddress();
        }
        return this.address;
    }
    async signMessage(message) {
        return await this.smartAccountAPI.signMessage(message);
    }
    async approvePlugin(plugin, validUntil, validAfter, data) {
        const sender = await this.getAddress();
        const ownerSig = await this.originalSigner._signTypedData({
            name: 'Kernel',
            version: '0.0.1',
            chainId: (await this.provider.getNetwork()).chainId,
            verifyingContract: sender
        }, {
            ValidateUserOpPlugin: [
                { name: 'plugin', type: 'address' },
                { name: 'validUntil', type: 'uint48' },
                { name: 'validAfter', type: 'uint48' },
                { name: 'data', type: 'bytes' }
            ]
        }, {
            plugin: plugin.address,
            validUntil,
            validAfter,
            data: (0, utils_1.hexlify)(data)
        });
        return (0, utils_2.fixSignedData)(ownerSig);
    }
    async signTypedData(typedData) {
        const digest = eth_sig_util_1.TypedDataUtils.eip712Hash(typedData, eth_sig_util_1.SignTypedDataVersion.V4);
        return (0, utils_2.fixSignedData)(await this.originalSigner.signMessage(digest));
    }
    async _signTypedData(domain, types, value) {
        const message = utils_1._TypedDataEncoder.getPayload(domain, types, value);
        return await this.signTypedData(message);
    }
    async signTransaction(transaction) {
        throw new Error('not implemented');
    }
    async signUserOperation(userOperation) {
        const message = await this.smartAccountAPI.getUserOpHash(userOperation);
        return await this.originalSigner.signMessage(message);
    }
    async getExecBatchTransaction(calls, options) {
        const calldata = await this.smartAccountAPI.encodeExecuteBatch(calls);
        return Object.assign(Object.assign({}, options), { to: (0, multisend_1.getMultiSendAddress)(), value: 0, data: calldata });
    }
    async execBatch(calls, options) {
        const transaction = await this.getExecBatchTransaction(calls, options);
        return await this.sendTransaction(transaction, BaseAccountAPI_1.ExecuteType.EXECUTE_BATCH);
    }
    async execDelegateCall(call, options) {
        return await this.sendTransaction(Object.assign(Object.assign({}, options), { to: call.to, data: call.data }), BaseAccountAPI_1.ExecuteType.EXECUTE_DELEGATE);
    }
    async listAssets() {
        const moralisApiService = new MoralisApiService_1.default();
        const chainId = await this.getChainId();
        const address = await this.getAddress();
        const assets = [];
        const nativeAsset = await moralisApiService.getNativeBalance(chainId, address);
        if (nativeAsset !== undefined)
            assets.push(nativeAsset);
        const tokenAssets = await moralisApiService.getTokenBalances(chainId, address);
        if (tokenAssets !== undefined)
            assets.push(...tokenAssets);
        const nftAssets = await moralisApiService.getNFTBalances(chainId, address);
        if (nftAssets !== undefined)
            assets.push(...nftAssets);
        return assets;
    }
    async transferAllAssets(to, assets, options) {
        const selfAddress = await this.getAddress();
        const calls = assets.map(async (asset) => {
            switch (asset.assetType) {
                case AssetType.ETH:
                    return {
                        to,
                        value: asset.amount ? asset.amount : await this.provider.getBalance(selfAddress),
                        data: '0x'
                    };
                case AssetType.ERC20:
                    const erc20 = (0, utils_2.getERC20Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc20.interface.encodeFunctionData('transfer', [to, asset.amount ? asset.amount : await erc20.balanceOf(selfAddress)])
                    };
                case AssetType.ERC721:
                    const erc721 = (0, utils_2.getERC721Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc721.interface.encodeFunctionData('transferFrom', [selfAddress, to, asset.tokenId])
                    };
                case AssetType.ERC1155:
                    const erc1155 = (0, utils_2.getERC1155Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc1155.interface.encodeFunctionData('safeTransferFrom', [selfAddress, to, asset.tokenId, asset.amount ? asset.amount : await erc1155.balanceOf(selfAddress, asset.tokenId), '0x'])
                    };
            }
        });
        const awaitedCall = await Promise.all(calls);
        return await this.execBatch(awaitedCall, options);
    }
}
exports.ZeroDevSigner = ZeroDevSigner;
//# sourceMappingURL=ZeroDevSigner.js.map