import { BigNumber, BigNumberish, Signer } from 'ethers';
import { Provider } from '@ethersproject/providers';
import { UserOperationStruct } from '@zerodevapp/contracts';
import { TransactionDetailsForUserOp } from './TransactionDetailsForUserOp';
import { Bytes, BytesLike, Result } from 'ethers/lib/utils';
import { PaymasterAPI } from './paymasters/PaymasterAPI';
import { NotPromise } from '@account-abstraction/utils';
import { GasOverheads } from './calcPreVerificationGas';
import { HttpRpcClient } from './HttpRpcClient';
import { MultiSendCall } from './multisend';
export interface BaseApiParams {
    owner: Signer;
    index?: number;
    provider: Provider;
    entryPointAddress: string;
    accountAddress?: string;
    overheads?: Partial<GasOverheads>;
    paymasterAPI?: PaymasterAPI;
    httpRpcClient?: HttpRpcClient;
    chainId?: number;
    onlySendSponsoredTransaction?: boolean;
}
export type AccountAPIArgs<T = {}> = BaseApiParams & T;
export type AccountAPIConstructor<T extends BaseAccountAPI, A = {}> = new (args: AccountAPIArgs<BaseApiParams & A>) => T;
export declare enum ExecuteType {
    EXECUTE = "execute",
    EXECUTE_DELEGATE = "executeDelegate",
    EXECUTE_BATCH = "executeBatch"
}
export interface UserOpResult {
    transactionHash: string;
    success: boolean;
}
interface FeeData {
    maxFeePerGas: BigNumber | null;
    maxPriorityFeePerGas: BigNumber | null;
}
/**
 * Base class for all Smart Wallet ERC-4337 Clients to implement.
 * Subclass should inherit 5 methods to support a specific wallet contract:
 *
 * - getAccountInitCode - return the value to put into the "initCode" field, if the account is not yet deployed. should create the account instance using a factory contract.
 * - getNonce - return current account's nonce value
 * - encodeExecute - encode the call from entryPoint through our account to the target contract.
 * - signUserOpHash - sign the hash of a UserOp.
 *
 * The user can use the following APIs:
 * - createUnsignedUserOp - given "target" and "calldata", fill userOp to perform that operation from the account.
 * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it
 */
export declare abstract class BaseAccountAPI {
    private isPhantom;
    private readonly entryPointView;
    owner: Signer;
    index: number;
    provider: Provider;
    overheads?: Partial<GasOverheads>;
    entryPointAddress: string;
    accountAddress?: string;
    paymasterAPI?: PaymasterAPI;
    httpRpcClient?: HttpRpcClient;
    chainId?: number;
    onlySendSponsoredTransaction?: boolean;
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     */
    protected constructor(params: BaseApiParams);
    /**
     * Creates an instance of a class extending BaseAccountAPI.
     * This static factory method is used to bypass the protected constructor constraint
     * and allows the creation of instances without directly calling the constructor.
     *
     * @param AccountAPIConstructor - The constructor of the class extending BaseAccountAPI.
     * @param args - The constructor arguments to be passed to the AccountAPIConstructor.
     * @returns An instance of the provided class.
     */
    static create<T extends BaseAccountAPI, A>(AccountAPIConstructor: new (args: AccountAPIArgs<A>) => T, args: AccountAPIArgs<A>): T;
    init(): Promise<this>;
    /**
     * return the value to put into the "initCode" field, if the contract is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    abstract getAccountInitCode(): Promise<string>;
    /**
     * return current account's nonce.
     */
    abstract getNonce(): Promise<BigNumber>;
    /**
     * encode the call from entryPoint through our account to the target contract.
     * @param target
     * @param value
     * @param data
     */
    abstract encodeExecute(target: string, value: BigNumberish, data: string): Promise<string>;
    /**
     * encode the delegatecall from entryPoint through our account to the target contract.
     * @param target
     * @param value
     * @param data
     */
    abstract encodeExecuteDelegate(target: string, value: BigNumberish, data: string): Promise<string>;
    /**
     * decode the delegatecall from entryPoint through our account to the target contract.
     * @param data
     */
    abstract decodeExecuteDelegate(data: BytesLike): Promise<Result>;
    /**
     * Encodes a batch of method calls for execution.
     *
     * @template A - The call's arguments type.
     * @template T - The options type for execution.
     * @param {Array<Call>} calls - An array of method calls to be encoded and executed.
     * @returns {Promise<string>} - A Promise that resolves to the encoded batch of method calls.
     * @throws {Error} - Throws an error if the method is not implemented in the child class.
     */
    abstract encodeExecuteBatch(calls: MultiSendCall[]): Promise<string>;
    /**
     * sign a userOp's hash (userOpHash).
     * @param userOpHash
     */
    abstract signUserOpHash(userOpHash: string): Promise<string>;
    abstract signMessage(message: Bytes | string): Promise<string>;
    abstract getFactoryAddress(): Promise<string>;
    abstract getFactoryAccountInitCode(): Promise<string>;
    /**
     * check if the contract is already deployed.
     */
    checkAccountPhantom(): Promise<boolean>;
    /**
     * calculate the account address even before it is deployed
     */
    getCounterFactualAddress(): Promise<string>;
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    getInitCode(): Promise<string>;
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    getVerificationGasLimit(): Promise<BigNumberish>;
    /**
     * should cover cost of putting calldata on-chain, and some overhead.
     * actual overhead depends on the expected bundle size
     */
    getPreVerificationGas(userOp: Partial<UserOperationStruct>): Promise<number>;
    /**
     * ABI-encode a user operation. used for calldata cost estimation
     */
    packUserOp(userOp: NotPromise<UserOperationStruct>): string;
    /**
     * Encodes the user operation call data and calculates the gas limit for the transaction.
     *
     * @param detailsForUserOp - The transaction details for the user operation.
     * @returns A promise that resolves to an object containing the encoded call data and the calculated gas limit as a BigNumber.
     */
    encodeUserOpCallDataAndGasLimit(detailsForUserOp: TransactionDetailsForUserOp, executeType?: ExecuteType): Promise<{
        callData: string;
        callGasLimit: BigNumber;
    }>;
    /**
     * return userOpHash for signing.
     * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)
     * @param userOp userOperation, (signature field ignored)
     */
    getUserOpHash(userOp: UserOperationStruct): Promise<string>;
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    getAccountAddress(): Promise<string>;
    estimateCreationGas(initCode?: string): Promise<BigNumberish>;
    /**
     * create a UserOperation, filling all details (except signature)
     * - if account is not yet created, add initCode to deploy it.
     * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the account is created)
     * @param info
     */
    createUnsignedUserOp(info: TransactionDetailsForUserOp, executeType?: ExecuteType): Promise<UserOperationStruct>;
    /**
     * Sign the filled userOp.
     * @param userOp the UserOperation to sign (with signature field ignored)
     */
    signUserOp(userOp: UserOperationStruct): Promise<UserOperationStruct>;
    /**
     * helper method: create and sign a user operation.
     * @param info transaction details for the userOp
     */
    createSignedUserOp(info: TransactionDetailsForUserOp, executeType?: ExecuteType): Promise<UserOperationStruct>;
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout stop waiting after this timeout
     * @param interval time to wait between polls.
     * @return the transactionHash this userOp was mined, or null if not found.
     */
    getUserOpReceipt(userOpHash: string, timeout?: number, interval?: number): Promise<string | null>;
    getFeeData(): Promise<FeeData>;
}
export {};
