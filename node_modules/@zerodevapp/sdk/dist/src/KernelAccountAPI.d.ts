import { BigNumber, BigNumberish } from 'ethers';
import { Bytes, BytesLike, Result } from 'ethers/lib/utils';
import { Signer } from '@ethersproject/abstract-signer';
import { BaseApiParams, BaseAccountAPI } from './BaseAccountAPI';
import { MultiSendCall } from './multisend';
import { Kernel, KernelFactory } from '@zerodevapp/contracts-new';
/**
 * constructor params, added on top of base params:
 * @param owner the signer object for the account owner
 * @param index nonce value used when creating multiple accounts for the same owner
 * @param factoryAddress address of factory to deploy new contracts (not needed if account already deployed)
 */
export interface KernelAccountApiParams extends BaseApiParams {
    owner: Signer;
    index?: number;
    factoryAddress?: string;
    templateAddress?: string;
}
/**
 * An implementation of the BaseAccountAPI using Gnosis Safe.
 * - Pass "owner" address and "index" nonce to the factory
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce is a public variable "nonce"
 * - execute method is "execTransactionFromModule()", since the entrypoint is set as a module
 */
export declare class KernelAccountAPI extends BaseAccountAPI {
    factoryAddress?: string;
    owner: Signer;
    accountContract?: Kernel;
    factory?: KernelFactory;
    constructor(params: KernelAccountApiParams);
    _getAccountContract(): Promise<Kernel>;
    /**
     * return the value to put into the "initCode" field, if the account is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    getAccountInitCode(): Promise<string>;
    getFactoryAddress(): Promise<string>;
    getFactoryAccountInitCode(): Promise<string>;
    getNonce(): Promise<BigNumber>;
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    encodeExecute(target: string, value: BigNumberish, data: string): Promise<string>;
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    encodeExecuteDelegate(target: string, value: BigNumberish, data: string): Promise<string>;
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    decodeExecuteDelegate(data: BytesLike): Promise<Result>;
    encodeExecuteBatch(calls: MultiSendCall[]): Promise<string>;
    signUserOpHash(userOpHash: string): Promise<string>;
    signMessage(message: Bytes | string): Promise<string>;
}
