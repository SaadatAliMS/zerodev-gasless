"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InfuraWebsocketProvider = void 0;
const ethers_1 = require("ethers");
const WEBSOCKET_PING_INTERVAL = 10000;
const WEBSOCKET_PONG_TIMEOUT = 5000;
const WEBSOCKET_RECONNECT_DELAY = 100;
const WebSocketProviderClass = () => class {
};
class InfuraWebsocketProvider extends WebSocketProviderClass() {
    constructor(network, apiKey) {
        super();
        this.events = [];
        this.requests = {};
        this.handler = {
            get(target, prop, receiver) {
                const value = (target.provider != null) && Reflect.get(target.provider, prop, receiver);
                return value instanceof Function ? value.bind(target.provider) : value;
            }
        };
        this.create(network, apiKey);
        return new Proxy(this, this.handler);
    }
    create(network, apiKey) {
        if (this.provider != null) {
            this.events = [...this.events, ...this.provider._events];
            this.requests = Object.assign(Object.assign({}, this.requests), this.provider._requests);
        }
        const provider = new ethers_1.ethers.providers.InfuraWebSocketProvider(network, apiKey);
        let pingInterval;
        let pongTimeout;
        provider._websocket.on('open', () => {
            pingInterval = setInterval(() => {
                provider._websocket.ping();
                pongTimeout = setTimeout(() => { provider._websocket.terminate(); }, WEBSOCKET_PONG_TIMEOUT);
            }, WEBSOCKET_PING_INTERVAL);
            let event;
            while (((event = this.events.pop()) != null)) {
                provider._events.push(event);
                provider._startEvent(event);
            }
            for (const key in this.requests) {
                provider._requests[key] = this.requests[key];
                provider._websocket.send(this.requests[key].payload);
                delete this.requests[key];
            }
        });
        provider._websocket.on('pong', () => {
            if (pongTimeout != null)
                clearTimeout(pongTimeout);
        });
        provider._websocket.on('close', (code) => {
            provider._wsReady = false;
            if (pingInterval != null)
                clearInterval(pingInterval);
            if (pongTimeout != null)
                clearTimeout(pongTimeout);
            if (code !== 1000) {
                setTimeout(() => this.create(network, apiKey), WEBSOCKET_RECONNECT_DELAY);
            }
        });
        this.provider = provider;
    }
}
exports.InfuraWebsocketProvider = InfuraWebsocketProvider;
//# sourceMappingURL=InfuraWebSocketProvider.js.map