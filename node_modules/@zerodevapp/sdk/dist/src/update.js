"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateController = void 0;
const contracts_1 = require("@zerodevapp/contracts");
const ethers_1 = require("ethers");
const constants = __importStar(require("./constants"));
class UpdateController {
    constructor(signer) {
        this.signer = signer;
        this.updateAvailable = false;
    }
    async checkUpdate(latestAccountFactoryAddr) {
        try {
            if (await this.signer.smartAccountAPI.checkAccountPhantom()) {
                // undeployed, no need to update
                return false;
            }
            const accountFactory = contracts_1.GnosisSafeAccountFactory__factory.connect(latestAccountFactoryAddr, this.signer);
            const latestManagerAddr = await accountFactory.eip4337Manager();
            const latestSingletonAddr = await accountFactory.safeSingleton();
            const accountAddr = await this.signer.getAddress();
            // Check if manager is outdated
            const manager = contracts_1.EIP4337Manager__factory.connect(latestManagerAddr, this.signer); // get manager address from factory
            const res = await manager.getCurrentEIP4337Manager(accountAddr);
            if (res[1] !== latestManagerAddr) {
                this.updateAvailable = true;
                this.managerUpdateInfo = {
                    prev: res[0],
                    oldManager: res[1],
                    newManager: latestManagerAddr
                };
            }
            // Check if singleton is outdated
            const currentSingletonAddr = storageToAddress(await this.signer.provider.getStorageAt(accountAddr, '0x'));
            if (currentSingletonAddr !== latestSingletonAddr) {
                this.updateAvailable = true;
                this.singletonUpdateInfo = {
                    newSingleton: latestSingletonAddr
                };
            }
            return this.updateAvailable;
        }
        catch (err) {
            throw new Error(`Error while checking for 4337 account updates: ${err}`);
        }
    }
    // Execute the update as a multi-call
    async update() {
        if (!this.updateAvailable) {
            return;
        }
        const batch = [];
        if (this.managerUpdateInfo != null) {
            const { prev, oldManager, newManager } = this.managerUpdateInfo;
            const manager = contracts_1.EIP4337Manager__factory.connect(newManager, this.signer);
            batch.push({
                to: manager.address,
                data: await manager.interface.encodeFunctionData('replaceEIP4337Manager', [prev, oldManager, newManager]),
                delegateCall: true
            });
        }
        if (this.singletonUpdateInfo != null) {
            const updateSingleton = contracts_1.UpdateSingleton__factory.connect(constants.UPDATE_SINGLETON_ADDRESS, this.signer);
            batch.push({
                to: updateSingleton.address,
                data: await updateSingleton.interface.encodeFunctionData('update', [this.singletonUpdateInfo.newSingleton]),
                delegateCall: true
            });
        }
        return await this.signer.execBatch(batch, {
            // The accounts we are attempting to upgrade at the moment are having
            // issues with batching on polygon due to gas estimation errors, so
            // we manually provide a gas limit here.
            // TODO: remove these once those accounts have been upgraded.
            gasLimit: 100000
        });
    }
}
exports.UpdateController = UpdateController;
function storageToAddress(storage) {
    return ethers_1.utils.getAddress(ethers_1.BigNumber.from(storage).toHexString());
}
//# sourceMappingURL=update.js.map