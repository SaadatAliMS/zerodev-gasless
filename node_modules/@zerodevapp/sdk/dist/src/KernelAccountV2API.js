"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KernelAccountV2API = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const multisend_1 = require("./multisend");
const kernel_contracts_v2_1 = require("@zerodevapp/kernel-contracts-v2");
const utils_2 = require("./utils");
/**
 * An implementation of the BaseAccountAPI using Gnosis Safe.
 * - Pass "owner" address and "index" nonce to the factory
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce is a public variable "nonce"
 * - execute method is "execTransactionFromModule()", since the entrypoint is set as a module
 */
class KernelAccountV2API extends BaseAccountAPI_1.BaseAccountAPI {
    constructor(params) {
        var _a;
        super(params);
        this.factoryAddress = params.factoryAddress;
        this.defaultValidator = params.defaultValidator;
        this.validator = (_a = params.validator) !== null && _a !== void 0 ? _a : params.defaultValidator;
    }
    async _getAccountContract() {
        if (this.accountContract == null) {
            this.accountContract = kernel_contracts_v2_1.Kernel__factory.connect(await this.getAccountAddress(), this.provider);
        }
        return this.accountContract;
    }
    /**
     * return the value to put into the "initCode" field, if the account is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    async getAccountInitCode() {
        const factoryAddr = await this.getFactoryAddress();
        const factoryInitCode = await this.getFactoryAccountInitCode();
        return (0, utils_1.hexConcat)([
            factoryAddr,
            factoryInitCode
        ]);
    }
    async getFactoryAddress() {
        if (this.factoryAddress != null) {
            return this.factoryAddress;
        }
        throw new Error('no factory address');
    }
    async getFactoryAccountInitCode() {
        if (this.factory == null) {
            if (this.factoryAddress != null && this.factoryAddress !== '') {
                this.factory = kernel_contracts_v2_1.KernelFactory__factory.connect(this.factoryAddress, this.provider);
            }
            else {
                throw new Error('no factory to get initCode');
            }
        }
        const encode = this.factory.interface.encodeFunctionData('createAccount', [this.defaultValidator.getAddress(), await this.defaultValidator.getEnableData(), this.index]);
        return encode;
    }
    async getNonce() {
        if (await this.checkAccountPhantom()) {
            return ethers_1.BigNumber.from(0);
        }
        const entryPoint = kernel_contracts_v2_1.EntryPoint__factory.connect(this.entryPointAddress, this.provider);
        return await entryPoint.getNonce(this.accountAddress, 0);
    }
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    async encodeExecute(target, value, data) {
        const accountContract = await this._getAccountContract();
        // the executeAndRevert method is defined on the manager
        const managerContract = kernel_contracts_v2_1.Kernel__factory.connect(accountContract.address, accountContract.provider);
        if (target.toLowerCase() === accountContract.address.toLowerCase() /*&& this.validator.mode != ValidatorMode.sudo*/) {
            return data;
        }
        else {
            return managerContract.interface.encodeFunctionData('execute', [
                target,
                value,
                data,
                0
            ]);
        }
    }
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    async encodeExecuteDelegate(target, value, data) {
        const accountContract = await this._getAccountContract();
        // the executeAndRevert method is defined on the manager
        const managerContract = kernel_contracts_v2_1.Kernel__factory.connect(accountContract.address, accountContract.provider);
        return managerContract.interface.encodeFunctionData('execute', [
            target,
            value,
            data,
            1
        ]);
    }
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    async decodeExecuteDelegate(data) {
        const accountContract = await this._getAccountContract();
        // the executeAndRevert method is defined on the manager
        const managerContract = kernel_contracts_v2_1.Kernel__factory.connect(accountContract.address, accountContract.provider);
        return managerContract.interface.decodeFunctionData('execute', data);
    }
    async encodeExecuteBatch(calls) {
        const multiSend = new ethers_1.Contract((0, multisend_1.getMultiSendAddress)(), [
            'function multiSend(bytes memory transactions)'
        ]);
        const multiSendCalldata = multiSend.interface.encodeFunctionData('multiSend', [(0, multisend_1.encodeMultiSend)(calls)]);
        return await this.encodeExecuteDelegate(multiSend.address, 0, multiSendCalldata);
    }
    async signUserOp(userOp) {
        const signature = await this.validator.getSignature(userOp);
        return Object.assign(Object.assign({}, userOp), { signature });
    }
    async signUserOpHash(userOpHash) {
        return await this.validator.signMessage((0, utils_1.arrayify)(userOpHash));
    }
    async signMessage(message) {
        const dataHash = ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.hashMessage(message));
        let sig = (0, utils_2.fixSignedData)(await this.validator.signMessage(dataHash));
        // If the account is undeployed, use ERC-6492
        if (await this.checkAccountPhantom()) {
            const coder = new ethers_1.ethers.utils.AbiCoder();
            sig = coder.encode(['address', 'bytes', 'bytes'], [
                await this.getFactoryAddress(),
                await this.getFactoryAccountInitCode(),
                sig
            ]) + '6492649264926492649264926492649264926492649264926492649264926492'; // magic suffix
        }
        return sig;
    }
}
exports.KernelAccountV2API = KernelAccountV2API;
//# sourceMappingURL=KernelAccountV2API.js.map