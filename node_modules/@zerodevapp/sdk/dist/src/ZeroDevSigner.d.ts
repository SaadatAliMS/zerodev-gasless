import { Deferrable } from '@ethersproject/properties';
import { Provider, TransactionRequest, TransactionResponse } from '@ethersproject/providers';
import { Signer } from '@ethersproject/abstract-signer';
import { BigNumber, Bytes, BigNumberish, ContractTransaction, Contract } from 'ethers';
import { ZeroDevProvider } from './ZeroDevProvider';
import { ClientConfig } from './ClientConfig';
import { HttpRpcClient, UserOperationReceipt } from './HttpRpcClient';
import { BaseAccountAPI, ExecuteType } from './BaseAccountAPI';
import { Call, DelegateCall } from './types';
import { UserOperationStruct } from '@zerodevapp/contracts';
export declare enum AssetType {
    ETH = 1,
    ERC20 = 2,
    ERC721 = 3,
    ERC1155 = 4
}
export interface AssetTransfer {
    assetType: AssetType;
    address?: string;
    tokenId?: BigNumberish;
    amount?: BigNumberish;
}
export interface ExecArgs {
    gasLimit?: number;
    maxFeePerGas?: BigNumberish;
    maxPriorityFeePerGas?: BigNumberish;
}
export declare class ZeroDevSigner extends Signer {
    readonly config: ClientConfig;
    readonly originalSigner: Signer;
    readonly zdProvider: ZeroDevProvider;
    readonly httpRpcClient: HttpRpcClient;
    readonly smartAccountAPI: BaseAccountAPI;
    constructor(config: ClientConfig, originalSigner: Signer, zdProvider: ZeroDevProvider, httpRpcClient: HttpRpcClient, smartAccountAPI: BaseAccountAPI);
    address?: string;
    sendTransaction(transaction: Deferrable<TransactionRequest>, executeBatchType?: ExecuteType, retryCount?: number): Promise<TransactionResponse>;
    isReplacementOpError(errorIn: any): boolean;
    resendTransactionWithIncreasedGasFees(transaction: Deferrable<TransactionRequest>, userOperation: UserOperationStruct, executeBatchType: ExecuteType, retryCount: number): Promise<TransactionResponse>;
    unwrapError(errorIn: any): Error;
    estimateGas(transaction: Deferrable<TransactionRequest>, executeBatchType?: ExecuteType): Promise<BigNumber>;
    getUserOperationReceipt(hash: string): Promise<UserOperationReceipt>;
    verifyAllNecessaryFields(transactionRequest: TransactionRequest): Promise<void>;
    connect(provider: Provider): Signer;
    getAddress(): Promise<string>;
    signMessage(message: Bytes | string): Promise<string>;
    approvePlugin(plugin: Contract, validUntil: BigNumber, validAfter: BigNumber, data: string): Promise<string>;
    signTypedData(typedData: any): Promise<string>;
    _signTypedData(domain: any, types: any, value: any): Promise<string>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    signUserOperation(userOperation: UserOperationStruct): Promise<string>;
    getExecBatchTransaction(calls: Call[], options?: ExecArgs): Promise<Deferrable<TransactionRequest>>;
    execBatch(calls: Call[], options?: ExecArgs): Promise<ContractTransaction>;
    execDelegateCall(call: DelegateCall, options?: ExecArgs): Promise<ContractTransaction>;
    listAssets(): Promise<AssetTransfer[]>;
    transferAllAssets(to: string, assets: AssetTransfer[], options?: ExecArgs): Promise<ContractTransaction>;
}
