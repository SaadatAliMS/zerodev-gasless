"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAccountAPI = exports.ExecuteType = void 0;
const ethers_1 = require("ethers");
const providers_1 = require("@ethersproject/providers");
const contracts_new_1 = require("@zerodevapp/contracts-new");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("@account-abstraction/utils");
const calcPreVerificationGas_1 = require("./calcPreVerificationGas");
const utils_3 = require("./utils");
const multisend_1 = require("./multisend");
const TokenPaymasterAPI_1 = require("./paymasters/TokenPaymasterAPI");
const gasPrice_1 = require("./gasPrice");
var ExecuteType;
(function (ExecuteType) {
    ExecuteType["EXECUTE"] = "execute";
    ExecuteType["EXECUTE_DELEGATE"] = "executeDelegate";
    ExecuteType["EXECUTE_BATCH"] = "executeBatch";
})(ExecuteType = exports.ExecuteType || (exports.ExecuteType = {}));
/**
 * Base class for all Smart Wallet ERC-4337 Clients to implement.
 * Subclass should inherit 5 methods to support a specific wallet contract:
 *
 * - getAccountInitCode - return the value to put into the "initCode" field, if the account is not yet deployed. should create the account instance using a factory contract.
 * - getNonce - return current account's nonce value
 * - encodeExecute - encode the call from entryPoint through our account to the target contract.
 * - signUserOpHash - sign the hash of a UserOp.
 *
 * The user can use the following APIs:
 * - createUnsignedUserOp - given "target" and "calldata", fill userOp to perform that operation from the account.
 * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it
 */
class BaseAccountAPI {
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     */
    constructor(params) {
        var _a;
        this.isPhantom = true;
        this.owner = params.owner;
        this.index = (_a = params.index) !== null && _a !== void 0 ? _a : 0;
        this.provider = params.provider;
        this.overheads = params.overheads;
        this.entryPointAddress = params.entryPointAddress;
        this.accountAddress = params.accountAddress;
        this.paymasterAPI = params.paymasterAPI;
        this.httpRpcClient = params.httpRpcClient;
        this.chainId = params.chainId;
        this.onlySendSponsoredTransaction = params.onlySendSponsoredTransaction;
        // factory "connect" define the contract address. the contract "connect" defines the "from" address.
        this.entryPointView = contracts_new_1.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers_1.ethers.constants.AddressZero);
    }
    /**
     * Creates an instance of a class extending BaseAccountAPI.
     * This static factory method is used to bypass the protected constructor constraint
     * and allows the creation of instances without directly calling the constructor.
     *
     * @param AccountAPIConstructor - The constructor of the class extending BaseAccountAPI.
     * @param args - The constructor arguments to be passed to the AccountAPIConstructor.
     * @returns An instance of the provided class.
     */
    static create(AccountAPIConstructor, args) {
        return new AccountAPIConstructor(args);
    }
    async init() {
        if (await this.provider.getCode(this.entryPointAddress) === '0x') {
            throw new Error(`entryPoint not deployed at ${this.entryPointAddress}`);
        }
        await this.getAccountAddress();
        return this;
    }
    /**
     * check if the contract is already deployed.
     */
    async checkAccountPhantom() {
        if (!this.isPhantom) {
            // already deployed. no need to check anymore.
            return this.isPhantom;
        }
        const senderAddressCode = await this.provider.getCode(this.getAccountAddress());
        if (senderAddressCode.length > 2) {
            // console.log(`SimpleAccount Contract already deployed at ${this.senderAddress}`)
            this.isPhantom = false;
        }
        else {
            // console.log(`SimpleAccount Contract is NOT YET deployed at ${this.senderAddress} - working in "phantom account" mode.`)
        }
        return this.isPhantom;
    }
    /**
     * calculate the account address even before it is deployed
     */
    async getCounterFactualAddress() {
        const initCode = await this.getAccountInitCode();
        // use entryPoint to query account address (factory can provide a helper method to do the same, but
        // this method attempts to be generic
        try {
            await this.entryPointView.callStatic.getSenderAddress(initCode);
        }
        catch (e) {
            if (e.errorArgs) {
                return e.errorArgs.sender;
            }
            else {
                throw e;
            }
        }
        throw new Error('must handle revert');
    }
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    async getInitCode() {
        if (await this.checkAccountPhantom()) {
            return await this.getAccountInitCode();
        }
        return '0x';
    }
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    async getVerificationGasLimit() {
        return 110000;
    }
    /**
     * should cover cost of putting calldata on-chain, and some overhead.
     * actual overhead depends on the expected bundle size
     */
    async getPreVerificationGas(userOp) {
        const p = await (0, utils_1.resolveProperties)(userOp);
        return (0, calcPreVerificationGas_1.calcPreVerificationGas)(p, this.overheads);
    }
    /**
     * ABI-encode a user operation. used for calldata cost estimation
     */
    packUserOp(userOp) {
        return (0, utils_2.packUserOp)(userOp, false);
    }
    /**
     * Encodes the user operation call data and calculates the gas limit for the transaction.
     *
     * @param detailsForUserOp - The transaction details for the user operation.
     * @returns A promise that resolves to an object containing the encoded call data and the calculated gas limit as a BigNumber.
     */
    async encodeUserOpCallDataAndGasLimit(detailsForUserOp, executeType = ExecuteType.EXECUTE) {
        var _a, _b;
        const value = (_a = (0, utils_3.parseNumber)(detailsForUserOp.value)) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from(0);
        let callData;
        switch (executeType) {
            case ExecuteType.EXECUTE_DELEGATE:
                callData = await this.encodeExecuteDelegate(detailsForUserOp.target, value, detailsForUserOp.data);
                break;
            case ExecuteType.EXECUTE_BATCH:
                callData = detailsForUserOp.data;
                break;
            case ExecuteType.EXECUTE:
            default:
                callData = await this.encodeExecute(detailsForUserOp.target, value, detailsForUserOp.data);
                break;
        }
        const callGasLimit = (_b = (0, utils_3.parseNumber)(detailsForUserOp.gasLimit)) !== null && _b !== void 0 ? _b : await this.provider.estimateGas({
            from: this.entryPointAddress,
            to: this.getAccountAddress(),
            data: callData
        });
        return {
            callData,
            callGasLimit
        };
    }
    /**
     * return userOpHash for signing.
     * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)
     * @param userOp userOperation, (signature field ignored)
     */
    async getUserOpHash(userOp) {
        // const chainId = await this.provider.getNetwork().then(net => net.chainId)
        // return getUserOpHash(op, this.entryPointAddress, chainId)
        return await this.entryPointView.getUserOpHash(Object.assign(Object.assign({}, userOp), { signature: '0x' }));
    }
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    async getAccountAddress() {
        if (this.accountAddress == null) { // means it needs deployment
            this.accountAddress = await this.getCounterFactualAddress();
        }
        return this.accountAddress;
    }
    async estimateCreationGas(initCode) {
        if (initCode == null || initCode === '0x')
            return 0;
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = '0x' + initCode.substring(42);
        return await this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
    }
    /**
     * create a UserOperation, filling all details (except signature)
     * - if account is not yet created, add initCode to deploy it.
     * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the account is created)
     * @param info
     */
    async createUnsignedUserOp(info, executeType = ExecuteType.EXECUTE) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const { callData, callGasLimit } = await this.encodeUserOpCallDataAndGasLimit(info, executeType);
        const initCode = await this.getInitCode();
        const verificationGasLimit = this.getVerificationGasLimit();
        const { maxFeePerGas, maxPriorityFeePerGas } = info;
        let feeData;
        // at least one of these needs to be set
        if (!maxFeePerGas && !maxPriorityFeePerGas) {
            try {
                let provider = null;
                if (this.provider instanceof providers_1.JsonRpcProvider) {
                    provider = this.provider;
                }
                if (provider === null && this.chainId !== undefined) {
                    provider = new providers_1.JsonRpcProvider((0, utils_3.getRpcUrl)(this.chainId));
                }
                if (provider !== null) {
                    feeData = (0, gasPrice_1.getGasPrice)(provider, this.getFeeData.bind(this));
                }
            }
            catch (_) { }
            if (feeData === undefined) {
                feeData = this.getFeeData();
            }
            // maxFeePerGas = feeData.maxFeePerGas ?? undefined
            // maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined
        }
        const initGas = this.estimateCreationGas(initCode);
        const partialUserOp = {
            sender: this.getAccountAddress(),
            nonce: (_a = info.nonce) !== null && _a !== void 0 ? _a : this.getNonce(),
            initCode,
            callData,
            callGasLimit: initCode.length > 2 ? ethers_1.BigNumber.from('1000000') : callGasLimit,
            verificationGasLimit: ethers_1.BigNumber.from(await verificationGasLimit).add(await initGas),
            maxFeePerGas: (feeData != null) ? ((_b = (await feeData).maxFeePerGas) !== null && _b !== void 0 ? _b : undefined) : maxFeePerGas,
            maxPriorityFeePerGas: (feeData != null) ? ((_c = (await feeData).maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : undefined) : maxPriorityFeePerGas,
            // Dummy values are required here
            paymasterAndData: '0xfe7dbcab8aaee4eb67943c1e6be95b1d065985c6000000000000000000000000000000000000000000000000000001869aa31cf400000000000000000000000000000000000000000000000000000000000000007dfe2190f34af27b265bae608717cdc9368b471fc0c097ab7b4088f255b4961e57b039e7e571b15221081c5dce7bcb93459b27a3ab65d2f8a889f4a40b4022801b',
            signature: (_d = info.dummySig) !== null && _d !== void 0 ? _d : '0x4046ab7d9c387d7a5ef5ca0777eded29767fd9863048946d35b3042d2f7458ff7c62ade2903503e15973a63a296313eab15b964a18d79f4b06c8c01c7028143c1c'
        };
        if (partialUserOp.callGasLimit.lt(40000)) {
            partialUserOp.callGasLimit = ethers_1.BigNumber.from(40000);
        }
        partialUserOp.preVerificationGas = this.getPreVerificationGas(partialUserOp);
        // this is needed for the 0.6 StackUp bundlers
        partialUserOp.paymasterAndData = '0x';
        let paymasterResp;
        if (this.paymasterAPI != null) {
            try {
                if (this.paymasterAPI instanceof TokenPaymasterAPI_1.TokenPaymasterAPI) {
                    let mainCall = {
                        to: info.target,
                        value: (_e = (0, utils_3.parseNumber)(info.value)) !== null && _e !== void 0 ? _e : ethers_1.BigNumber.from(0),
                        data: info.data
                    };
                    if (executeType === ExecuteType.EXECUTE_BATCH) {
                        mainCall = Object.assign(Object.assign({}, mainCall), { to: (0, multisend_1.getMultiSendAddress)(), delegateCall: true, data: (await this.decodeExecuteDelegate(info.data)).data });
                    }
                    const erc20UserOp = Object.assign(Object.assign({}, partialUserOp), { callData: await this.encodeExecuteBatch([
                            await this.paymasterAPI.createGasTokenApprovalRequest(this.provider),
                            mainCall
                        ]), callGasLimit: await this.provider.estimateGas({
                            from: this.entryPointAddress,
                            to: this.getAccountAddress(),
                            data: callData
                        }) });
                    paymasterResp = await this.paymasterAPI.getPaymasterResp(partialUserOp, erc20UserOp);
                }
                else {
                    paymasterResp = await this.paymasterAPI.getPaymasterResp(partialUserOp);
                }
            }
            catch (err) {
                console.log('failed to get paymaster data', err);
                // if the paymaster runs into any issue, just ignore it and use
                // the account's own balance instead
            }
        }
        partialUserOp.paymasterAndData = (_f = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.paymasterAndData) !== null && _f !== void 0 ? _f : '0x';
        if (this.onlySendSponsoredTransaction && partialUserOp.paymasterAndData === '0x')
            throw new Error('Transaction was not sponsored. Please make sure to sponsor transaction');
        const paymasterHasEstimates = (paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.preVerificationGas) !== undefined && (paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.verificationGasLimit) !== undefined && (paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callGasLimit) !== undefined;
        partialUserOp.preVerificationGas = (_g = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.preVerificationGas) !== null && _g !== void 0 ? _g : partialUserOp.preVerificationGas;
        partialUserOp.verificationGasLimit = (_h = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.verificationGasLimit) !== null && _h !== void 0 ? _h : partialUserOp.verificationGasLimit;
        partialUserOp.callGasLimit = (_j = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callGasLimit) !== null && _j !== void 0 ? _j : partialUserOp.callGasLimit;
        partialUserOp.callData = (_k = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callData) !== null && _k !== void 0 ? _k : partialUserOp.callData;
        partialUserOp.callGasLimit = (_l = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callGasLimit) !== null && _l !== void 0 ? _l : partialUserOp.callGasLimit;
        partialUserOp.maxPriorityFeePerGas = (_m = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.maxPriorityFeePerGas) !== null && _m !== void 0 ? _m : partialUserOp.maxPriorityFeePerGas;
        partialUserOp.maxFeePerGas = (_o = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.maxFeePerGas) !== null && _o !== void 0 ? _o : partialUserOp.maxFeePerGas;
        partialUserOp.callData = (_p = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callData) !== null && _p !== void 0 ? _p : partialUserOp.callData;
        if (this.httpRpcClient && !paymasterHasEstimates) {
            try {
                partialUserOp.preVerificationGas = ethers_1.BigNumber.from('100000');
                partialUserOp.verificationGasLimit = ethers_1.BigNumber.from('1000000');
                const { callGasLimit, preVerificationGas, verificationGas } = await this.httpRpcClient.estimateUserOpGas(partialUserOp);
                partialUserOp.preVerificationGas = (_q = ethers_1.BigNumber.from(preVerificationGas).mul(12).div(10)) !== null && _q !== void 0 ? _q : partialUserOp.preVerificationGas;
                partialUserOp.verificationGasLimit = (_r = ethers_1.BigNumber.from(verificationGas).mul(12).div(10)) !== null && _r !== void 0 ? _r : partialUserOp.verificationGasLimit;
                partialUserOp.callGasLimit = (_s = ethers_1.BigNumber.from(callGasLimit).mul(12).div(10)) !== null && _s !== void 0 ? _s : partialUserOp.callGasLimit;
                partialUserOp.callData = (_t = paymasterResp === null || paymasterResp === void 0 ? void 0 : paymasterResp.callData) !== null && _t !== void 0 ? _t : partialUserOp.callData;
            }
            catch (_) {
            }
        }
        return Object.assign(Object.assign({}, partialUserOp), { signature: '' });
    }
    /**
     * Sign the filled userOp.
     * @param userOp the UserOperation to sign (with signature field ignored)
     */
    async signUserOp(userOp) {
        const userOpHash = await this.getUserOpHash(userOp);
        const signature = (0, utils_3.fixSignedData)(await this.signUserOpHash(userOpHash));
        return Object.assign(Object.assign({}, userOp), { signature });
    }
    /**
     * helper method: create and sign a user operation.
     * @param info transaction details for the userOp
     */
    async createSignedUserOp(info, executeType = ExecuteType.EXECUTE) {
        return await this.signUserOp(await this.createUnsignedUserOp(info, executeType));
    }
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout stop waiting after this timeout
     * @param interval time to wait between polls.
     * @return the transactionHash this userOp was mined, or null if not found.
     */
    async getUserOpReceipt(userOpHash, timeout = 30000, interval = 5000) {
        const endtime = Date.now() + timeout;
        while (Date.now() < endtime) {
            const events = await this.entryPointView.queryFilter(this.entryPointView.filters.UserOperationEvent(userOpHash));
            if (events.length > 0) {
                return events[0].transactionHash;
            }
            await new Promise(resolve => setTimeout(resolve, interval));
        }
        return null;
    }
    // Ethers' getFeeData function hardcodes 1.5 gwei as the minimum tip, which
    // turns out to be too large for some L2s like Arbitrum.  So we rolled our own
    // function for estimating miner tip
    async getFeeData() {
        var _a;
        const { block, gasPrice } = await (0, utils_1.resolveProperties)({
            block: this.provider.getBlock('latest'),
            gasPrice: this.provider.getGasPrice().catch((error) => {
                return null;
            })
        });
        let maxFeePerGas = gasPrice;
        let maxPriorityFeePerGas = gasPrice;
        if (block && (block.baseFeePerGas != null)) {
            // Set the tip to the min of the tip for the last block and 1.5 gwei
            const minimumTip = ethers_1.BigNumber.from(this.chainId === 137 ? '30000000000' : '1500000000');
            maxPriorityFeePerGas = (_a = gasPrice === null || gasPrice === void 0 ? void 0 : gasPrice.sub(block.baseFeePerGas)) !== null && _a !== void 0 ? _a : null;
            if ((maxPriorityFeePerGas == null) || maxPriorityFeePerGas.lt(0) || maxPriorityFeePerGas.gt(minimumTip)) {
                maxPriorityFeePerGas = minimumTip;
            }
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : 0);
        }
        return { maxFeePerGas, maxPriorityFeePerGas };
    }
}
exports.BaseAccountAPI = BaseAccountAPI;
//# sourceMappingURL=BaseAccountAPI.js.map