"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KillSwitchValidator = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const BaseValidator_1 = require("./BaseValidator");
class KillSwitchValidator extends BaseValidator_1.BaseValidatorAPI {
    constructor(params) {
        super(params);
        this.guardian = params.guardian;
        this.delaySeconds = params.delaySeconds;
    }
    async signer() {
        return this.guardian;
    }
    async getEnableData() {
        const data = (0, utils_1.hexConcat)([
            await this.guardian.getAddress(),
        ]);
        return data;
    }
    async signUserOp(userOperation) {
        const pausedUntil = Math.floor(Date.now() / 1000) + this.delaySeconds;
        const userOpHash = await this.entrypoint.getUserOpHash(Object.assign(Object.assign({}, userOperation), { signature: '0x' }));
        const signer = await this.signer();
        if (this.mode == BaseValidator_1.ValidatorMode.sudo) {
            return await signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        else {
            const hash = (0, utils_1.keccak256)((0, utils_1.hexConcat)([(0, utils_1.hexZeroPad)(ethers_1.BigNumber.from(pausedUntil).toHexString(), 6), userOpHash]));
            const signature = (0, utils_1.hexConcat)([(0, utils_1.hexZeroPad)(ethers_1.BigNumber.from(pausedUntil).toHexString(), 6), await signer.signMessage((0, utils_1.arrayify)(hash))]);
            return signature;
        }
    }
    async signMessage(message) {
        const signer = await this.signer();
        const signature = await signer.signMessage((0, utils_1.arrayify)(message));
        return signature;
    }
}
exports.KillSwitchValidator = KillSwitchValidator;
//# sourceMappingURL=KillSwitchValidator.js.map