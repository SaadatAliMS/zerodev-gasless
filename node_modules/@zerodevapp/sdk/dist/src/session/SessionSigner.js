"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionSigner = exports.DEFAULT_SESSION_KEY_PLUGIN = void 0;
const contracts_new_1 = require("@zerodevapp/contracts-new");
const merkletreejs_1 = require("merkletreejs");
const ZeroDevSigner_1 = require("../ZeroDevSigner");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const BaseAccountAPI_1 = require("../BaseAccountAPI");
const constants = __importStar(require("../constants"));
// Deterministically deployed against 0.6 EntryPoint
exports.DEFAULT_SESSION_KEY_PLUGIN = '0x6E2631aF80bF7a9cEE83F590eE496bCc2E40626D';
class SessionSigner extends ZeroDevSigner_1.ZeroDevSigner {
    constructor(config, provider, httpRpcClient, smartAccountAPI, validUntil, whitelist, signature, sessionKeySigner, sessionKeyPlugin) {
        super(config, sessionKeySigner, provider, httpRpcClient, smartAccountAPI);
        this.sessionKeyPlugin = (sessionKeyPlugin != null)
            ? sessionKeyPlugin
            : contracts_new_1.ZeroDevSessionKeyPlugin__factory.connect(exports.DEFAULT_SESSION_KEY_PLUGIN, this.provider);
        this.sessionKey = sessionKeySigner;
        this.validUntil = validUntil;
        this.whitelist = whitelist;
        const policyPacked = [];
        for (const policy of whitelist) {
            if (policy.selectors === undefined || policy.selectors.length == 0) {
                policyPacked.push((0, utils_1.hexConcat)([policy.to]));
            }
            else {
                for (const selector of policy.selectors) {
                    policyPacked.push((0, utils_1.hexConcat)([policy.to, selector]));
                }
            }
        }
        this.signature = signature;
        this.merkleTree = policyPacked.length == 0 ? new merkletreejs_1.MerkleTree([(0, utils_1.hexZeroPad)('0x00', 32)], utils_1.keccak256, { hashLeaves: false }) : new merkletreejs_1.MerkleTree(policyPacked, utils_1.keccak256, { sortPairs: true, hashLeaves: true });
    }
    // This one is called by Contract. It signs the request and passes in to Provider to be sent.
    async sendTransaction(transaction, executeBatchType = BaseAccountAPI_1.ExecuteType.EXECUTE, retryCount = 0) {
        var _a, _b, _c, _d, _e, _f;
        if (transaction.maxFeePerGas || transaction.maxPriorityFeePerGas) {
            transaction.maxFeePerGas = 0;
            transaction.maxPriorityFeePerGas = 0;
        }
        else {
            transaction.gasPrice = 0;
        }
        let userOperation;
        userOperation = await this.smartAccountAPI.createUnsignedUserOp({
            target: (_a = transaction.to) !== null && _a !== void 0 ? _a : '',
            data: (_c = (_b = transaction.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '0x',
            value: transaction.value,
            nonce: await this.currentSessionNonce(),
            gasLimit: await transaction.gasLimit,
            maxFeePerGas: transaction.maxFeePerGas,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
            dummySig: '0x6e2631af80bf7a9cee83f590ee496bcc2e40626d00174876e7ff0000000000004ad85583a52b543ce5ead0473886a8ff50077f8182e8f4350b4f1d860fcc6aa07cb7f74235c717724cd32bab184746ae6d3d00226dc7104f27eb2edf4bbf06b11c000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000034caa60260e791b70058a14d187de68f714044b37f05eaab83a3be5d647d901736f86c7d4f5d53f4e4cdd65816e451fbf5c69b8bec00000000000000000000000000000000000000000000000000000000000000000000000000000000000000961434be7f35132e97915633bc1fc020364ea51348639d7bd9eb7f34316a60d4099cb7f81466c3a89cb2f3a2b2e28d5e16224f02a896430516fd72ebef28ee4410e0ff004fe111dad283416cddab1005aff41a85ccd51b0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        }, executeBatchType);
        userOperation.signature = await this.signUserOperation(userOperation);
        const transactionResponse = await this.zdProvider.constructUserOpTransactionResponse(userOperation);
        // Invoke the transaction hook
        (_e = (_d = this.config.hooks) === null || _d === void 0 ? void 0 : _d.transactionStarted) === null || _e === void 0 ? void 0 : _e.call(_d, {
            hash: transactionResponse.hash,
            from: transaction.from,
            to: transaction.to,
            value: (transaction.value || 0),
            sponsored: userOperation.paymasterAndData !== '0x'
        });
        try {
            await this.httpRpcClient.sendUserOpToBundler(userOperation);
        }
        catch (error) {
            // console.error('sendUserOpToBundler failed', error)
            if (this.isReplacementOpError(error)) {
                console.error('Resending tx with Increased Gas fees');
                if (retryCount >= ((_f = this.config.maxTxRetries) !== null && _f !== void 0 ? _f : constants.DEFAULT_MAX_TX_RETRIES)) {
                    throw new Error('Maximum retry attempts exceeded');
                }
                return await this.resendTransactionWithIncreasedGasFees(transaction, userOperation, executeBatchType, retryCount);
            }
            throw this.unwrapError(error);
        }
        // TODO: handle errors - transaction that is "rejected" by bundler is _not likely_ to ever resolve its "wait()"
        return transactionResponse;
    }
    isReplacementOpError(errorIn) {
        var _a, _b;
        if (errorIn.body != null) {
            const errorBody = JSON.parse(errorIn.body);
            const failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
            return (_b = failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('replacement op must increase maxFeePerGas and MaxPriorityFeePerGas')) !== null && _b !== void 0 ? _b : false;
        }
        return false;
    }
    async resendTransactionWithIncreasedGasFees(transaction, userOperation, executeBatchType, retryCount) {
        retryCount++;
        const maxFeePerGas = ethers_1.BigNumber.from(userOperation.maxFeePerGas).mul(113).div(100);
        const maxPriorityFeePerGas = ethers_1.BigNumber.from(userOperation.maxPriorityFeePerGas).mul(113).div(100);
        return await (this === null || this === void 0 ? void 0 : this.sendTransaction(Object.assign(Object.assign({}, transaction), { maxFeePerGas, maxPriorityFeePerGas }), executeBatchType, retryCount));
    }
    async approvePlugin(plugin, validUntil, validAfter, data) {
        throw new Error('Cannot approve plugin for session signer');
    }
    async signUserOperation(userOp) {
        userOp.signature = this.signature; // reuse same proof for all transactions
        return await this.signUserOpWithSessionKey(userOp);
    }
    async currentSessionNonce() {
        return await this.getSessionNonce(await this.sessionKey.getAddress());
    }
    async getSessionNonce(address) {
        return await contracts_new_1.Kernel__factory.connect(await this.getAddress(), this.provider)['getNonce(uint192)'](ethers_1.BigNumber.from(address)).catch(e => {
            // this happens when the account hasn't been deployed
            if (e.method === 'getNonce(uint192)' && e.data === '0x') {
                return ethers_1.BigNumber.from(0);
            }
            return Promise.reject(e);
        });
    }
    async signUserOpWithSessionKey(userOp) {
        const opHash = await this.smartAccountAPI.getUserOpHash(userOp);
        const addr = '0x' + (await userOp.callData).toString().slice(34, 74);
        const selector = '0x' + (await userOp.callData).toString().slice(330, 338);
        const found = this.whitelist.find((item) => {
            return item.to.toLowerCase() == addr.toLowerCase();
        });
        let merkleLeaf = '';
        if ((found != null) && this.whitelist.length > 0) {
            if (found.selectors === undefined || found.selectors.length == 0) {
                merkleLeaf = (0, utils_1.hexZeroPad)(addr, 20);
            }
            else if (found.selectors.includes(selector)) {
                merkleLeaf = (0, utils_1.hexConcat)([addr, (0, utils_1.hexZeroPad)(selector, 4)]);
            }
        }
        else if (this.whitelist.length == 0) {
            merkleLeaf = (0, utils_1.hexZeroPad)('0x00', 32);
        }
        else {
            throw new Error('Address not in whitelist');
        }
        if (this.validUntil <= Math.floor(Date.now() / 1000)) {
            throw new Error('Session key is expired.');
        }
        const nonce = await this.currentSessionNonce();
        const sessionsig = await this.sessionKey._signTypedData({
            name: 'ZeroDevSessionKeyPlugin',
            version: '0.0.1',
            chainId: await this.provider.getNetwork().then(net => net.chainId),
            verifyingContract: await userOp.sender
        }, {
            Session: [
                { name: 'userOpHash', type: 'bytes32' },
                { name: 'nonce', type: 'uint256' }
            ]
        }, {
            userOpHash: (0, utils_1.hexZeroPad)(opHash, 32),
            nonce
        });
        const proof = this.whitelist.length > 0 ? this.merkleTree.getHexProof((0, utils_1.keccak256)(merkleLeaf)) : [(0, utils_1.hexZeroPad)('0x00', 32)];
        return (0, utils_1.hexConcat)([
            (0, utils_1.hexConcat)([
                this.sessionKeyPlugin.address,
                (0, utils_1.hexZeroPad)('0x' + this.validUntil.toString(16), 6),
                (0, utils_1.hexZeroPad)('0x000000000000', 6),
                (0, utils_1.hexZeroPad)(userOp.signature.toString(), 65) // signature
            ]),
            utils_1.defaultAbiCoder.encode([
                'bytes',
                'bytes'
            ], [
                (0, utils_1.hexConcat)([
                    await this.sessionKey.getAddress(),
                    (0, utils_1.hexZeroPad)('0x' + this.merkleTree.getRoot().toString('hex'), 32)
                ]),
                (0, utils_1.hexConcat)([
                    (0, utils_1.hexZeroPad)('0x' + ((merkleLeaf.length - 2) / 2).toString(16), 1),
                    (0, utils_1.hexZeroPad)(merkleLeaf, (merkleLeaf.length - 2) / 2),
                    (0, utils_1.hexZeroPad)(sessionsig, 65),
                    utils_1.defaultAbiCoder.encode([
                        'bytes32[]'
                    ], [
                        proof
                    ])
                ])
            ])
        ]);
    }
}
exports.SessionSigner = SessionSigner;
//# sourceMappingURL=SessionSigner.js.map